<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moebius Strip 3D Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: transparent;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            background: transparent;
        }
    </style>
</head>
<body>
    <canvas id="moebiusCanvas"></canvas>

    <script>
        const canvas = document.getElementById('moebiusCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Configuration
        const config = {
            majorRadius: Math.min(canvas.width, canvas.height) * 0.25, // R - radius of centerline
            stripWidth: Math.min(canvas.width, canvas.height) * 0.08, // Width of the strip
            centerX: canvas.width / 2,
            centerY: canvas.height / 2,
            flowSpeed: 0.015, // Speed of the flowing animation
            uSegments: 80, // Segments around the strip
            vSegments: 16, // Segments across the strip width
            shadingDensity: 1000, // Number of impressionistic shading lines
        };

        // Blue color palette
        const colors = {
            light: ['#ADD8E6', '#B0E0E6', '#AFEEEE', '#87CEEB'], // Light blue
            medium: ['#4682B4', '#5F9EA0', '#4169E1', '#6495ED'], // Azure/medium blue
            dark: ['#00008B', '#000080', '#191970', '#0C2340'], // Dark blue
            shadow: ['#020B1A', '#010610', '#000000'] // Deep shadow
        };

        // 3D Point class
        class Point3D {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotatedX = x;
                this.rotatedY = y;
                this.rotatedZ = z;
                this.projected2DX = 0;
                this.projected2DY = 0;
            }
        }

        // Line class
        class Line {
            constructor(point1, point2, color, width) {
                this.point1 = point1;
                this.point2 = point2;
                this.color = color;
                this.width = width;
            }
        }

        // Create Moebius strip points using parametric equations
        function createMoebiusPoints(flowOffset = 0) {
            const points = [];

            // Parametric equations for Moebius strip:
            // x = (R + v * cos(u/2)) * cos(u)
            // y = (R + v * cos(u/2)) * sin(u)
            // z = v * sin(u/2)
            // where u ∈ [0, 2π] and v ∈ [-width, +width]

            for (let i = 0; i <= config.uSegments; i++) {
                const u = (i * 2 * Math.PI) / config.uSegments + flowOffset;

                for (let j = 0; j <= config.vSegments; j++) {
                    const v = (j / config.vSegments - 0.5) * 2 * config.stripWidth;

                    const x = (config.majorRadius + v * Math.cos(u / 2)) * Math.cos(u);
                    const y = (config.majorRadius + v * Math.cos(u / 2)) * Math.sin(u);
                    const z = v * Math.sin(u / 2);

                    points.push(new Point3D(x, y, z));
                }
            }

            return points;
        }

        // Create structural lines for Moebius strip
        function createStructuralLines(points) {
            const lines = [];

            // Lines along the strip (u direction)
            for (let i = 0; i <= config.uSegments; i++) {
                for (let j = 0; j < config.vSegments; j++) {
                    const index = i * (config.vSegments + 1) + j;
                    const nextIndex = i * (config.vSegments + 1) + j + 1;
                    lines.push(new Line(points[index], points[nextIndex]));
                }
            }

            // Lines across the strip (v direction)
            for (let j = 0; j <= config.vSegments; j++) {
                for (let i = 0; i < config.uSegments; i++) {
                    const index = i * (config.vSegments + 1) + j;
                    const nextIndex = (i + 1) * (config.vSegments + 1) + j;
                    lines.push(new Line(points[index], points[nextIndex]));
                }
            }

            return lines;
        }

        // Create impressionistic shading lines on Moebius strip
        function createShadingLines(flowOffset = 0) {
            const lines = [];

            for (let i = 0; i < config.shadingDensity; i++) {
                // Random points on Moebius strip surface
                const u1 = Math.random() * 2 * Math.PI + flowOffset;
                const v1 = (Math.random() - 0.5) * 2 * config.stripWidth;

                // Nearby point for shading effect
                const u2 = u1 + (Math.random() - 0.5) * 0.3;
                const v2 = v1 + (Math.random() - 0.5) * config.stripWidth * 0.3;

                // Calculate 3D positions using Moebius parametric equations
                const x1 = (config.majorRadius + v1 * Math.cos(u1 / 2)) * Math.cos(u1);
                const y1 = (config.majorRadius + v1 * Math.cos(u1 / 2)) * Math.sin(u1);
                const z1 = v1 * Math.sin(u1 / 2);

                const x2 = (config.majorRadius + v2 * Math.cos(u2 / 2)) * Math.cos(u2);
                const y2 = (config.majorRadius + v2 * Math.cos(u2 / 2)) * Math.sin(u2);
                const z2 = v2 * Math.sin(u2 / 2);

                lines.push(new Line(new Point3D(x1, y1, z1), new Point3D(x2, y2, z2)));
            }

            return lines;
        }

        // Initialize geometry with flow animation
        let flowOffset = 0;
        let moebiusPoints = createMoebiusPoints(flowOffset);
        let structuralLines = createStructuralLines(moebiusPoints);
        let shadingLines = createShadingLines(flowOffset);
        let allLines = [...structuralLines, ...shadingLines];

        // Rotation angles for 3D viewing
        let angleX = Math.PI / 6; // Tilt for better viewing
        let angleY = 0;
        let angleZ = 0;

        // Rotation matrix functions
        function rotateX(point, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const y = point.y * cos - point.z * sin;
            const z = point.y * sin + point.z * cos;
            return { x: point.x, y, z };
        }

        function rotateY(point, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const x = point.x * cos + point.z * sin;
            const z = -point.x * sin + point.z * cos;
            return { x, y: point.y, z };
        }

        function rotateZ(point, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const x = point.x * cos - point.y * sin;
            const y = point.x * sin + point.y * cos;
            return { x, y, z: point.z };
        }

        // Project 3D point to 2D
        function project3D(point) {
            const perspective = 800;
            const scale = perspective / (perspective + point.rotatedZ);
            point.projected2DX = point.rotatedX * scale + config.centerX;
            point.projected2DY = point.rotatedY * scale + config.centerY;
            return scale;
        }

        // Get color based on lighting (simulated)
        function getColorForPoint(point) {
            // Light source from front-top-right
            const lightX = 0.5;
            const lightY = -0.7;
            const lightZ = 1;

            // Calculate approximate normal for Moebius strip surface
            // Using the rotated position as an approximation
            const dist = Math.sqrt(point.rotatedX * point.rotatedX + point.rotatedY * point.rotatedY + point.rotatedZ * point.rotatedZ);
            const normalX = point.rotatedX / dist;
            const normalY = point.rotatedY / dist;
            const normalZ = point.rotatedZ / dist;

            // Calculate dot product (lighting intensity)
            const lighting = normalX * lightX + normalY * lightY + normalZ * lightZ;

            // Map lighting to color palette
            if (lighting > 0.5) {
                return colors.light[Math.floor(Math.random() * colors.light.length)];
            } else if (lighting > 0) {
                return colors.medium[Math.floor(Math.random() * colors.medium.length)];
            } else if (lighting > -0.3) {
                return colors.dark[Math.floor(Math.random() * colors.dark.length)];
            } else {
                return colors.shadow[Math.floor(Math.random() * colors.shadow.length)];
            }
        }

        // Rotate and project all points
        function updateGeometry() {
            // Update all points in all lines
            const allPoints = new Set();
            allLines.forEach(line => {
                allPoints.add(line.point1);
                allPoints.add(line.point2);
            });

            allPoints.forEach(point => {
                // Apply rotation for 3D viewing
                let rotated = rotateX(point, angleX);
                rotated = rotateY(rotated, angleY);
                rotated = rotateZ(rotated, angleZ);

                point.rotatedX = rotated.x;
                point.rotatedY = rotated.y;
                point.rotatedZ = rotated.z;

                project3D(point);
            });

            // Update line colors based on lighting
            allLines.forEach(line => {
                const midPoint = {
                    rotatedX: (line.point1.rotatedX + line.point2.rotatedX) / 2,
                    rotatedY: (line.point1.rotatedY + line.point2.rotatedY) / 2,
                    rotatedZ: (line.point1.rotatedZ + line.point2.rotatedZ) / 2
                };

                line.color = getColorForPoint(midPoint);
                // Vary line width based on depth
                const avgZ = (line.point1.rotatedZ + line.point2.rotatedZ) / 2;
                line.width = avgZ > 0 ? 0.8 : 0.4;
            });
        }

        // Draw all lines
        function drawLines() {
            // Sort lines by depth (back to front)
            const sortedLines = allLines.slice().sort((a, b) => {
                const avgZA = (a.point1.rotatedZ + a.point2.rotatedZ) / 2;
                const avgZB = (b.point1.rotatedZ + b.point2.rotatedZ) / 2;
                return avgZA - avgZB;
            });

            sortedLines.forEach(line => {
                // Only draw if both points are visible (basic culling)
                const avgZ = (line.point1.rotatedZ + line.point2.rotatedZ) / 2;

                // Calculate opacity based on depth
                const opacity = avgZ > 0 ? 0.9 : 0.5;

                ctx.beginPath();
                ctx.strokeStyle = line.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                ctx.lineWidth = line.width;
                ctx.moveTo(line.point1.projected2DX, line.point1.projected2DY);
                ctx.lineTo(line.point2.projected2DX, line.point2.projected2DY);
                ctx.stroke();
            });
        }

        // Animation loop
        function animate() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update flow offset to create flowing animation
            flowOffset += config.flowSpeed;

            // Recreate geometry with new flow offset for smooth animation
            moebiusPoints = createMoebiusPoints(flowOffset);
            structuralLines = createStructuralLines(moebiusPoints);
            shadingLines = createShadingLines(flowOffset);
            allLines = [...structuralLines, ...shadingLines];

            // Optionally add slow rotation for visual interest
            angleY += 0.002;

            // Update and draw
            updateGeometry();
            drawLines();

            // Continue animation
            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            config.centerX = canvas.width / 2;
            config.centerY = canvas.height / 2;
            config.majorRadius = Math.min(canvas.width, canvas.height) * 0.25;
            config.stripWidth = Math.min(canvas.width, canvas.height) * 0.08;
        });

        // Start animation
        animate();
    </script>
</body>
</html>
